# 125. Valid Palindrome 문제 풀이

## **문제 설명**

주어진 문자열 `s`가 회문(Palindrome)인지 확인하는 문제이다. 회문은 대소문자를 구분하지 않고, 알파벳과 숫자만 고려하며, 앞뒤가 동일한 문자열을 말한다.

<br>

## **나의 문제 풀이**

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function (s) {
  /**
   * 문자열 정제
   *
   * 입력된 문자열에서 알파벳(a-z, A-Z)과 숫자(0-9)를 제외한 모든 문자를 제거하고,
   * 남은 문자열을 소문자로 변환한다.
   */
  let str = s.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();

  // 글자 시작(start)과 끝(end) 포인터를 설정
  let start = 0;
  let end = str.length - 1;

  // 시작 포인터와 끝 포인터가 서로 만나거나 교차하기 전까지 반복
  while (start < end) {
    // 시작 포인터와 끝 포인터가 가리키는 문자가 동일한지 확인
    if (str[start] === str[end]) {
      start++;
      end--;
    } else {
      // 문자가 다르면 false를 반환
      return false;
    }
  }
  // 끝까지 동일하면 true를 반환
  return true;
};
```

### 시간 복잡도

- 문자열 정제: `replace`와 `toLowerCase`는 각각 O(n)
- 회문 검사: 두 포인터를 사용하여 문자열 비교 O(n)
- 총합: O(n) + O(n) = O(n)

### 공간 복잡도

- 정제된 문자열(str)을 저장하므로 O(n)의 추가 메모리가 필요
- 포인터(start와 end)는 상수 크기의 메모리만 사용
- 총합: O(n)

<br>

## **다른 문제 풀이**

나는 미리 정규화를 시키고 소문자로 변경을 해서 작업을 했다면 이 풀이법은

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function (s) {
  // 포인터 초기화
  let start = 0;
  let end = s.length - 1;

  // 두 포인터가 만나거나 교차하기 전까지 반복
  while (start < end) {
    // 시작 포인터가 알파벳/숫자가 아닐 경우 오른쪽으로 이동
    while (start < end && !isAlphaNumeric(s[start])) {
      start++;
    }

    // 끝 포인터가 알파벳/숫자가 아닐 경우 왼쪽으로 이동
    while (start < end && !isAlphaNumeric(s[end])) {
      end--;
    }

    // 두 문자가 동일하지 않으면 false 반환
    if (s[start].toLowerCase() !== s[end].toLowerCase()) {
      return false;
    }

    // 포인터 이동
    start++;
    end--;
  }

  // 모든 비교가 끝나면 true 반환
  return true;
};

// 알파벳/숫자인지 확인하는 함수
function isAlphaNumeric(char) {
  const code = char.charCodeAt(0);
  // 아스키 코드로 문자 범위를 확인
  return (
    (code >= 48 && code <= 57) || // 숫자 (0-9)
    (code >= 65 && code <= 90) || // 대문자 (A-Z)
    (code >= 97 && code <= 122) // 소문자 (a-z)
  );
}
```

### 시간 복잡도

- 각 문자를 한 번씩 순회하며 비교하므로 O(n)

### 공간 복잡도

- 문자열을 새로 생성하지 않고 상수 크기의 포인터만 사용하므로 O(1)

<br>

## 나의 풀이와 다른 풀이의 차이점

| 항목                 | 나의 풀이                                                                                 | 다른 풀이                                                                                   |
| -------------------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| **문자열 정제 방식** | 정규식을 사용해 알파벳/숫자를 제외한 문자를 제거하고 소문자로 변환하여 새로운 문자열 생성 | 포인터를 사용해 동적으로 알파벳/숫자가 아닌 문자를 건너뛰고, 비교 시에만 소문자로 변환      |
| **공간 복잡도**      | 정제된 문자열을 저장하기 위해 \( O(n) \)의 추가 메모리가 필요                             | 새로운 문자열을 생성하지 않고 상수 크기의 포인터만 사용하므로 \( O(1) \)                    |
| **시간 복잡도**      | 문자열 정제와 비교가 각각 \( O(n) \)이므로 총 \( O(n) \)                                  | 각 문자를 한 번씩 순회하며 비교하므로 \( O(n) \)                                            |
| **가독성**           | 정규식을 활용하여 문자열 정제가 직관적이며 초보자도 쉽게 이해할 수 있는 코드 구조         | 포인터와 조건문을 활용한 동적 처리로 약간 복잡하지만 메모리 효율성과 성능을 우선시하는 방식 |
| **적용 가능성**      | 메모리 사용량이 중요하지 않고, 일반적인 입력 크기의 문제에 적합                           | 대규모 입력 데이터나 메모리 제약이 있는 환경에서 더 적합                                    |
| **유지보수성**       | 간단하고 명확한 구조로 협업 환경에서 선호됨                                               | 동적 처리가 복잡해질 가능성이 있지만, 최적화가 필요한 프로젝트에서는 유리                   |

<br>
